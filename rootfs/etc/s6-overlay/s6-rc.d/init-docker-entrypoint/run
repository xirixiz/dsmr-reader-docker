#!/command/with-contenv bash
# shellcheck shell=bash

#---------------------------------------------------------------------------------------------------------------------------
# VARIABLES
#---------------------------------------------------------------------------------------------------------------------------
: "${DEBUG:=false}"

#---------------------------------------------------------------------------------------------------------------------------
# FUNCTIONS
#---------------------------------------------------------------------------------------------------------------------------
function _info()  { printf "\r[ \033[00;34mINFO\033[0m ] %s\n" "$@"; }
function _warn()  { printf "\r\033[2K[ \033[0;33mWARN\033[0m ] %s\n" "$@"; }
function _error() { printf "\r\033[2K[ \033[0;31mFAIL\033[0m ] %s\n" "$@"; }
function _debug() { printf "\r[ \033[00;37mDBUG\033[0m ] %s\n" "$@"; }
function _progress() { printf "\r[ \033[00;34mINFO\033[0m ] %s" "$@"; }

function _normalize_bool_env() {
    # normalizes an ENV var in place, defaults to false
    local var="$1"
    local val
    val="$(printenv "${var}" 2>/dev/null || true)"

    case "${val,,}" in
        true|1|yes|y|on) export "${var}=true" ;;
        *)               export "${var}=false" ;;
    esac
}

function _normalize_all_enable_vars() {
    # normalize all ENABLE_* vars from the environment
    local var
    while IFS='=' read -r var _; do
        [[ "${var}" == ENABLE_* ]] || continue
        _normalize_bool_env "${var}"
    done < <(printenv)
}

function _pre_reqs() {
    _info "DSMR Reader Reader release: ${DSMR_VERSION}"
    _info "DSMR Reader Reader Docker release: ${DOCKER_TARGET_RELEASE}"

    DUID=${DUID:-803}
    DGID=${DGID:-803}

    groupmod -o -g "${DGID}" app >/dev/null 2>&1 || true
    usermod -o -u "${DUID}" app >/dev/null 2>&1 || true

    cat /etc/s6-overlay/s6-rc.d/init-docker-entrypoint/branding
    echo "
    User UID: $(id -u app)
    User GID: $(id -g app)
    ───────────────────────────────────────────────────
    "

    time32="$(date +%Y)"
    if [[ "${time32}" == "1970" || "${time32}" == "1969" ]] && [[ "$(uname -m)" == "armv7l" ]]; then
        echo 'Your DockerHost is running an outdated version of libseccomp. Search internet to fix this!'
        sleep infinity
    fi

    _info "Ensure permissions..."
    mkdir -p \
      /defaults \
      /var/www/dsmrreader

    chown -R app:app /defaults \
      /var/www/dsmrreader

    touch /app/.env
    chown app:app /app/.env

    if [[ "${ENABLE_RESET_ENV_ON_STARTUP:-false}" == "true" ]]; then
        _info "Clean .env settings on container (re)start..."
        : > /app/.env
    else
        touch /app/.env
    fi

    _normalize_all_enable_vars
    _detect_architecture

    # Prepare runtime nginx snippet dirs (writable for app user)
    mkdir -p /run/nginx/conf.d /run/nginx/server-snippets
    chown -R app:app /run/nginx
}

function _detect_architecture() {
    local arch longbit
    arch="$(uname -m)"
    longbit="$(getconf LONG_BIT)"

    case "${arch}" in
        x86_64)
            if [[ "${longbit}" == "32" ]]; then _info "Using architecture: X32"; else _info "Using architecture: X64"; fi
            ;;
        armv7l) _info "Using architecture: ARM" ;;
        aarch64) _info "Using architecture: ARM64" ;;
        unknown) _info "Using architecture: X64" ;;
        *) _info "Using architecture: ${arch}" ;;
    esac
}

function _dsmr_datalogger_mode() {
    touch /app/.env
    if [[ "${DSMRREADER_OPERATION_MODE}" != @(standalone|api_server|api_client) ]]; then
        _error "DSMRREADER_OPERATION_MODE required value is incorrect. Exiting..."
        exit 1
    else
        if [[ "${DSMRREADER_OPERATION_MODE}" = standalone ]]; then
            _info "Configuring DSMR Reader to run all processes in a single container with a serial or ipv4 datalogger..."

            if [[ "${DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD}" = serial ]]; then
                _info "Using a serial connection for the DSMR Reader remote datalogger..."
                if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT}" || -z "${DSMRREADER_REMOTE_DATALOGGER_SERIAL_BYTESIZE}" || -z "${DSMRREADER_REMOTE_DATALOGGER_SERIAL_BAUDRATE}" ]]; then
                    _error "DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT and/or DSMRREADER_REMOTE_DATALOGGER_SERIAL_BYTESIZE and/or DSMRREADER_REMOTE_DATALOGGER_SERIAL_BAUDRATE required values are not set. Exiting..."
                    exit 1
                else
                    _info "Fixing ${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT} security..."
                    if ls "${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT}" 1>/dev/null 2>&1; then
                        chmod 666 "${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT}"
                    fi
                    _info "Adding serial input method configuration settings..."
                    {
                        echo DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD="${DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD}"
                        echo DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT="${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT}"
                        echo DSMRREADER_REMOTE_DATALOGGER_SERIAL_BAUDRATE="${DSMRREADER_REMOTE_DATALOGGER_SERIAL_BAUDRATE}"
                        echo DSMRREADER_REMOTE_DATALOGGER_SERIAL_BYTESIZE="${DSMRREADER_REMOTE_DATALOGGER_SERIAL_BYTESIZE}"
                        echo DSMRREADER_REMOTE_DATALOGGER_SERIAL_PARITY="${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PARITY}"
                    } >>/app/.env
                fi
            fi

            if [[ "${DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD}" = ipv4 ]]; then
                _info "Using an ipv4 network socket for the datalogger..."
                if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_NETWORK_HOST}" || -z "${DSMRREADER_REMOTE_DATALOGGER_NETWORK_PORT}" ]]; then
                    _error "DSMRREADER_REMOTE_DATALOGGER_NETWORK_HOST and/or DSMRREADER_REMOTE_DATALOGGER_NETWORK_PORT required values are not set. Exiting..."
                    exit 1
                else
                    _info "Adding ipv4 input method configuration settings..."
                    {
                        echo DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD="${DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD}"
                        echo DSMRREADER_REMOTE_DATALOGGER_NETWORK_HOST="${DSMRREADER_REMOTE_DATALOGGER_NETWORK_HOST}"
                        echo DSMRREADER_REMOTE_DATALOGGER_NETWORK_PORT="${DSMRREADER_REMOTE_DATALOGGER_NETWORK_PORT}"
                    } >>/app/.env
                fi
            fi
        fi

        if [[ "${DSMRREADER_OPERATION_MODE}" = api_server ]]; then
            _info "Configuring DSMR Reader to run without the datalogger process. A remote datalogger (api_client) is required..."
        fi

        if [[ "${DSMRREADER_OPERATION_MODE}" = api_client ]]; then
            _info "Configuring DSMR Reader to only start the api client datalogger (API_CLIENT), which sends the P1 telegrams to the server (API_SERVER)..."
            if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_API_HOSTS}" || -z "${DSMRREADER_REMOTE_DATALOGGER_API_KEYS}" ]]; then
                _error "DSMRREADER_REMOTE_DATALOGGER_API_HOSTS and/or DSMRREADER_REMOTE_DATALOGGER_API_KEYS required values are not set. Exiting..."
                exit 1
            else
                _info "Adding remote datalogger (api_client) configuration settings..."
                {
                    echo DSMRREADER_REMOTE_DATALOGGER_API_HOSTS="${DSMRREADER_REMOTE_DATALOGGER_API_HOSTS}"
                    echo DSMRREADER_REMOTE_DATALOGGER_API_KEYS="${DSMRREADER_REMOTE_DATALOGGER_API_KEYS}"
                } >>/app/.env
            fi
        fi
    fi
}

function _optional_settings() {
    if [[ -n "${DSMRREADER_REMOTE_DATALOGGER_TIMEOUT}" ]]; then
        _info "Adding DSMRREADER_REMOTE_DATALOGGER_TIMEOUT to the DSMR Reader remote datalogger configuration..."
        echo DSMRREADER_REMOTE_DATALOGGER_TIMEOUT="${DSMRREADER_REMOTE_DATALOGGER_TIMEOUT}" >>/app/.env
    fi

    if [[ -n "${DSMRREADER_REMOTE_DATALOGGER_SLEEP}" ]]; then
        _info "Adding DSMRREADER_REMOTE_DATALOGGER_SLEEP to the DSMR Reader remote datalogger configuration..."
        echo DSMRREADER_REMOTE_DATALOGGER_SLEEP="${DSMRREADER_REMOTE_DATALOGGER_SLEEP}" >>/app/.env
    fi

    if [[ -n "${DSMRREADER_REMOTE_DATALOGGER_DEBUG_LOGGING}" ]]; then
        _info "Adding DSMRREADER_REMOTE_DATALOGGER_DEBUG_LOGGING to the DSMR Reader remote datalogger configuration..."
        echo DSMRREADER_REMOTE_DATALOGGER_DEBUG_LOGGING="${DSMRREADER_REMOTE_DATALOGGER_DEBUG_LOGGING^^}" >>/app/.env
    fi

    if [[ -n "${DSMRREADER_LOGLEVEL}" ]]; then
        _info "Adding DSMRREADER_LOGLEVEL to the DSMR Reader configuration..."
        echo DSMRREADER_LOGLEVEL="${DSMRREADER_LOGLEVEL^^}" >>/app/.env
    fi
}

function _check_db_availability() {
    _info "Verifying if the DSMR Reader web credential variables have been set..."
    if [[ -z "${DSMRREADER_ADMIN_USER}" ]] || [[ -z "${DSMRREADER_ADMIN_PASSWORD}" ]]; then
        _error "DSMR Reader web credentials (DSMRREADER_ADMIN_USER or DSMRREADER_ADMIN_PASSWORD) not set. Exiting..."
        exit 1
    fi
    if [[ -n "${DJANGO_DATABASE_ENGINE}" ]]; then
        _info "Verifying database connectivity to host: ${DJANGO_DATABASE_HOST} with port: ${DJANGO_DATABASE_PORT}..."
        for i in {1..10}; do
            if ! nc -z "${DJANGO_DATABASE_HOST}" "${DJANGO_DATABASE_PORT}" > /dev/null 2>&1; then
                _progress "Testing database connectivity: ${i} second(s) of 10 seconds..."
                sleep 1
                if [[ $i == 10 ]]; then
                    _error "Database connectivity couldn't be verified! Please verify your settings. Exiting..."
                    exit 1
                fi
            else
                _info "Database connectivity successfully verified!"
                if [[ "${ENABLE_VACUUM_DB_ON_STARTUP}" = true ]]; then
                    _cleandb
                fi
                break
            fi
        done
    fi
}

function _run_post_config() {
    _info "Running post configuration..."
    /opt/venv/bin/python /app/manage.py migrate --noinput
    /opt/venv/bin/python /app/manage.py collectstatic --noinput
    /opt/venv/bin/python /app/manage.py dsmr_superuser
}

function _nginx_listen_port() {
    mkdir -p /run/nginx/server-snippets
    local port="${NGINX_LISTEN_PORT:-80}"
    _info "NGINX listen port set to ${port}..."
    printf 'listen %s;\n' "${port}" > /run/nginx/server-snippets/10-listen.conf
}

function _nginx_disable_access_logs() {
    mkdir -p /run/nginx/conf.d
    if [[ "${ENABLE_NGINX_ACCESS_LOGS}" = false ]]; then
        _info "Disabling NGINX access logs via override config..."
        cat > /run/nginx/conf.d/00-nginx-logging.conf <<'EOF'
access_log off;
error_log  /proc/self/fd/2 warn;
EOF
    else
        _info "Routing NGINX access and error logs to stdout/stderr..."
        cat > /run/nginx/conf.d/00-nginx-logging.conf <<'EOF'
access_log /proc/self/fd/1;
error_log  /proc/self/fd/2 warn;
EOF
    fi
}

function _nginx_ssl_configuration() {
    mkdir -p /run/nginx/server-snippets
    rm -f /run/nginx/server-snippets/20-ssl.conf

    if [[ "${ENABLE_NGINX_SSL}" = true ]]; then
        _info "Enabling NGINX SSL..."

        if [[ ! -f "/etc/ssl/private/fullchain.pem" || ! -f "/etc/ssl/private/privkey.pem" ]]; then
            _error "SSL enabled but /etc/ssl/private/fullchain.pem and/or /etc/ssl/private/privkey.pem are missing!"
            exit 1
        fi

        cat > /run/nginx/server-snippets/20-ssl.conf <<'EOF'
listen 443 ssl;
ssl_certificate /etc/ssl/private/fullchain.pem;
ssl_certificate_key /etc/ssl/private/privkey.pem;
ssl_protocols TLSv1.2 TLSv1.3;
EOF

        if nginx -c /etc/nginx/nginx.conf -t >/dev/null 2>&1; then
            _info "NGINX SSL configured and enabled"
        else
            _error "NGINX configuration error"
            nginx -c /etc/nginx/nginx.conf -t || true
            exit 1
        fi
    else
        _info "ENABLE_NGINX_SSL is disabled, nothing to configure."
    fi
}

function _generate_auth_configuration() {
    mkdir -p /run/nginx/server-snippets
    rm -f /run/nginx/server-snippets/30-auth.conf /run/nginx/htpasswd

    _info "Checking for HTTP AUTHENTICATION configuration..."
    if [[ "${ENABLE_HTTP_AUTH}" = true ]]; then
        _info "ENABLE_HTTP_AUTH is enabled, generating htpasswd..."

        if [[ -z "${HTTP_AUTH_USERNAME}" || -z "${HTTP_AUTH_PASSWORD}" ]]; then
            _error "ENABLE_HTTP_AUTH is true but HTTP_AUTH_USERNAME and/or HTTP_AUTH_PASSWORD are missing."
            exit 1
        fi

        local crypt_pw
        crypt_pw="$(openssl passwd -apr1 "${HTTP_AUTH_PASSWORD}")"
        printf "%s:%s\n" "${HTTP_AUTH_USERNAME}" "${crypt_pw}" > /run/nginx/htpasswd

        cat > /run/nginx/server-snippets/30-auth.conf <<'EOF'
auth_basic "Restricted application";
auth_basic_user_file /run/nginx/htpasswd;
EOF

        if nginx -c /etc/nginx/nginx.conf -t >/dev/null 2>&1; then
            _info "HTTP AUTHENTICATION configured and enabled"
        else
            _error "NGINX configuration error"
            nginx -c /etc/nginx/nginx.conf -t || true
            exit 1
        fi
    else
        _info "ENABLE_HTTP_AUTH is disabled, continuing..."
    fi
}

function _generate_clientcert_auth_configuration() {
    mkdir -p /run/nginx/server-snippets
    rm -f /run/nginx/server-snippets/40-clientcert.conf

    _info "Checking for CLIENT CERTIFICATE AUTHENTICATION configuration..."
    if [[ "${ENABLE_CLIENTCERT_AUTH}" = true ]]; then
        _info "ENABLE_CLIENTCERT_AUTH is enabled, configuring client cert auth..."

        if [[ ! -f /etc/nginx/client_cert/cacert.pem ]]; then
            _error "Please map a CA.pem file to /etc/nginx/client_cert/cacert.pem"
            exit 1
        fi

        cat > /run/nginx/server-snippets/40-clientcert.conf <<'EOF'
ssl_client_certificate /etc/nginx/client_cert/cacert.pem;
ssl_verify_client on;
EOF

        if [[ -f /etc/nginx/client_cert/ca.crl ]]; then
            echo "ssl_crl /etc/nginx/client_cert/ca.crl;" >> /run/nginx/server-snippets/40-clientcert.conf
        fi

        if nginx -c /etc/nginx/nginx.conf -t >/dev/null 2>&1; then
            _info "CLIENT CERT AUTHENTICATION configured and enabled"
        else
            _error "NGINX configuration error!"
            nginx -c /etc/nginx/nginx.conf -t || true
            exit 1
        fi
    else
        _info "ENABLE_CLIENTCERT_AUTH is disabled, continuing..."
    fi
}

function _docker_secrets {
    if find /run/s6/container_environment -maxdepth 1 -name 'FILE__*' -print -quit | grep -q .; then
        _info "Enabling Docker secrets..."
        for FILENAME in /run/s6/container_environment/FILE__*; do
            SECRETFILE=$(cat "${FILENAME}")
            if [[ -f ${SECRETFILE} ]]; then
                FILESTRIP=${FILENAME//FILE__/}
                if [[ $(tail -n1 "${SECRETFILE}" | wc -l) != 0 ]]; then
                    _info "Docker secret: ${FILENAME##*/} contains a trailing newline and may not work as expected!"
                fi
                cat "${SECRETFILE}" >"${FILESTRIP}"
                _info "Docker secret ${FILESTRIP##*/} set from ${FILENAME##*/}..."
            else
                _info "Cannot find Docker secret in ${FILENAME##*/}..."
            fi
        done
    fi
}

function _iframe {
    if [[ "${ENABLE_IFRAME}" = true ]]; then
        _info "Enabling IFrame..."
        sed -i "/^from dsmrreader.*/a X_FRAME_OPTIONS = 'ALLOWALL'" /app/dsmrreader/settings.py
    fi
}

function _cleandb {
    _info "Vacuum cleaning enabled. Vacuming database..."
    /app/cleandb.sh
}

#---------------------------------------------------------------------------------------------------------------------------
# MAIN
#---------------------------------------------------------------------------------------------------------------------------
[[ "${DEBUG}" = true ]] && set -o xtrace

_pre_reqs

if [[ "${DSMRREADER_OPERATION_MODE}" != api_client ]]; then
    _docker_secrets
    _check_db_availability
    _iframe
    _run_post_config
    _nginx_listen_port
    _nginx_disable_access_logs
    _generate_clientcert_auth_configuration
    _nginx_ssl_configuration
    _generate_auth_configuration
    _dsmr_datalogger_mode
    _optional_settings
fi
