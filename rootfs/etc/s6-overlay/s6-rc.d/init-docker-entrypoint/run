#!/command/with-contenv bash
# shellcheck shell=bash

#---------------------------------------------------------------------------------------------------------------------------
# STRICT MODE
#---------------------------------------------------------------------------------------------------------------------------
set -euo pipefail
IFS=$'\n\t'

#---------------------------------------------------------------------------------------------------------------------------
# VARIABLES
#---------------------------------------------------------------------------------------------------------------------------
: "${DEBUG:=false}"

# ------------------------------------------------------------------------------
# Default Django / Database environment (production-safe)
# ------------------------------------------------------------------------------

: "${DSMRREADER_OPERATION_MODE:=standalone}"
: "${DJANGO_DATABASE_ENGINE:=django.db.backends.postgresql}"
: "${DJANGO_DATABASE_HOST:=dsmrdb}"
: "${DJANGO_DATABASE_PORT:=5432}"
: "${DJANGO_DATABASE_NAME:=dsmrreader}"
: "${DJANGO_DATABASE_USER:=dsmrreader}"

# Secrets must EXIST but may be empty (for set -u safety)
: "${DJANGO_DATABASE_PASSWORD:=}"
: "${DJANGO_SECRET_KEY:=}"

export \
  DSMRREADER_OPERATION_MODE \
  DJANGO_DATABASE_ENGINE \
  DJANGO_DATABASE_HOST \
  DJANGO_DATABASE_PORT \
  DJANGO_DATABASE_NAME \
  DJANGO_DATABASE_USER \
  DJANGO_DATABASE_PASSWORD \
  DJANGO_SECRET_KEY

#---------------------------------------------------------------------------------------------------------------------------
# LOGGING FUNCTIONS
#---------------------------------------------------------------------------------------------------------------------------
function _log() {
    local level="$1"
    local color="$2"
    shift 2
    printf "\r[ \033[00;%sm%s\033[0m ] %s\n" "${color}" "${level}" "$*" >&2
}

function _info()     { _log "INFO" "34" "$@"; }
function _warn()     { _log "WARN" "33" "$@"; }
function _error()    { _log "FAIL" "31" "$@"; }
function _debug()    { _log "DBUG" "37" "$@"; }
function _success()  { _log "OKAY" "32" "$@"; }
function _progress() { printf "\r[ \033[00;34mINFO\033[0m ] %s" "$@"; }

#---------------------------------------------------------------------------------------------------------------------------
# UTILITY FUNCTIONS
#---------------------------------------------------------------------------------------------------------------------------
function _normalize_bool_env() {
    local var="$1"
    local val
    val="$(printenv "${var}" 2>/dev/null || echo "false")"

    case "${val,,}" in
        true|1|yes|y|on) export "${var}=true" ;;
        *)               export "${var}=false" ;;
    esac
}

function _normalize_all_enable_vars() {
    local var
    while IFS='=' read -r var _; do
        [[ "${var}" == ENABLE_* ]] || continue
        _normalize_bool_env "${var}"
    done < <(printenv)
}

function _detect_architecture() {
    local arch longbit
    arch="$(uname -m)"
    longbit="$(getconf LONG_BIT)"

    case "${arch}" in
        x86_64)
            if [[ "${longbit}" == "32" ]]; then
                _info "Architecture: X32"
            else
                _info "Architecture: X64"
            fi
            ;;
        armv7l)  _info "Architecture: ARM" ;;
        aarch64) _info "Architecture: ARM64" ;;
        *)       _info "Architecture: ${arch}" ;;
    esac
}

function _check_y2038_issue() {
    local time32
    time32="$(date +%Y)"

    if [[ "${time32}" == "1970" || "${time32}" == "1969" ]] && [[ "$(uname -m)" == "armv7l" ]]; then
        _error "Y2038 issue detected: Your Docker host has an outdated libseccomp version"
        _error "Please update libseccomp on your host system"
        _error "See: https://docs.linuxserver.io/faq#libseccomp"
        exit 1
    fi
}

#---------------------------------------------------------------------------------------------------------------------------
# VALIDATION FUNCTIONS
#---------------------------------------------------------------------------------------------------------------------------
function _validate_credentials() {
    local errors=0

    # Check admin credentials
    if [[ -z "${DSMRREADER_ADMIN_USER:-}" ]]; then
        _error "DSMRREADER_ADMIN_USER is not set"
        ((errors++))
    fi

    if [[ -z "${DSMRREADER_ADMIN_PASSWORD:-}" ]]; then
        _error "DSMRREADER_ADMIN_PASSWORD is not set"
        ((errors++))
    elif [[ "${DSMRREADER_ADMIN_PASSWORD}" == "dsmrreader" ]]; then
        _warn "Default DSMRREADER_ADMIN_PASSWORD detected - this is a security risk! Please set a secure password"
    fi

    # Check database credentials
    if [[ -z "${DJANGO_DATABASE_PASSWORD:-}" ]]; then
        _error "DJANGO_DATABASE_PASSWORD is not set"
        ((errors++))
    elif [[ "${DJANGO_DATABASE_PASSWORD}" == "dsmrreader" ]]; then
        _warn "Using default DJANGO_DATABASE_PASSWORD - this is a security risk! Please set a secure password"
    fi

    if [[ -z "${DJANGO_SECRET_KEY:-}" ]]; then
        _error "DJANGO_SECRET_KEY is not set"
        ((errors++))
    elif [[ "${DJANGO_SECRET_KEY}" == "dsmrreader" ]]; then
        _warn "Default DJANGO_SECRET_KEY detected - this is a security risk! Please set a secure password"
    fi

    [[ $errors -gt 0 ]] && exit 1
    return 0
}

function _validate_operation_mode() {
    local mode="${DSMRREADER_OPERATION_MODE}"

    case "${mode}" in
        standalone|api_server|api_client)
            _info "Operation mode: ${mode}"
            ;;
        *)
            _error "Invalid DSMRREADER_OPERATION_MODE: ${mode}"
            _error "Valid options: standalone, api_server, api_client"
            exit 1
            ;;
    esac
}

function _validate_serial_config() {
    local port="${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT:-}"

    if [[ -z "${port}" ]]; then
        _error "DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT is not set"
        return 1
    fi

    if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_SERIAL_BAUDRATE:-}" ]]; then
        _error "DSMRREADER_REMOTE_DATALOGGER_SERIAL_BAUDRATE is not set"
        return 1
    fi

    if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_SERIAL_BYTESIZE:-}" ]]; then
        _error "DSMRREADER_REMOTE_DATALOGGER_SERIAL_BYTESIZE is not set"
        return 1
    fi

    return 0
}

function _validate_network_config() {
    if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_NETWORK_HOST:-}" ]]; then
        _error "DSMRREADER_REMOTE_DATALOGGER_NETWORK_HOST is not set"
        return 1
    fi

    if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_NETWORK_PORT:-}" ]]; then
        _error "DSMRREADER_REMOTE_DATALOGGER_NETWORK_PORT is not set"
        return 1
    fi

    return 0
}

function _validate_api_client_config() {
    if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_API_HOSTS:-}" ]]; then
        _error "DSMRREADER_REMOTE_DATALOGGER_API_HOSTS is not set"
        return 1
    fi

    if [[ -z "${DSMRREADER_REMOTE_DATALOGGER_API_KEYS:-}" ]]; then
        _error "DSMRREADER_REMOTE_DATALOGGER_API_KEYS is not set"
        return 1
    fi

    return 0
}

#---------------------------------------------------------------------------------------------------------------------------
# SETUP FUNCTIONS
#---------------------------------------------------------------------------------------------------------------------------
function _pre_reqs() {
    _info "DSMR Reader version: ${DSMR_VERSION}"
    _info "Docker image version: ${DOCKER_TARGET_RELEASE}"

    _check_y2038_issue

    local DUID=${DUID:-803}
    local DGID=${DGID:-803}

    if ! groupmod -o -g "${DGID}" app 2>/dev/null; then
        _warn "Could not modify app group GID to ${DGID}"
    fi

    if ! usermod -o -u "${DUID}" app 2>/dev/null; then
        _warn "Could not modify app user UID to ${DUID}"
    fi

    cat /etc/s6-overlay/s6-rc.d/init-docker-entrypoint/branding
    echo "
    User UID: $(id -u app)
    User GID: $(id -g app)
    ───────────────────────────────────────────────────
    "

    _normalize_all_enable_vars
    _detect_architecture

    # Create required directories with proper permissions
    _info "Setting up directories and permissions..."
    mkdir -p \
        /defaults \
        /var/www/dsmrreader \
        /run/nginx/conf.d \
        /run/nginx/server-snippets \
        /run/gunicorn

    chown -R app:app \
        /defaults \
        /var/www/dsmrreader \
        /run/nginx \
        /run/gunicorn

    chmod 755 /run/gunicorn

    # Handle .env file
    if [[ "${ENABLE_RESET_ENV_ON_STARTUP:-true}" == "true" ]]; then
        _info "Resetting .env file on startup..."
        : > /app/.env
    else
        touch /app/.env
    fi

    chown app:app /app/.env
    chmod 600 /app/.env
}

function _configure_serial_port() {
    local port="${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT:-}"

    _info "Configuring serial port: ${port}"

    if [[ ! -e "${port}" ]]; then
        _warn "Serial port ${port} does not exist yet (may appear after device is plugged in)"
        return 0
    fi

    # Secure permissions: owner=app, group=dialout, mode=660
    if ! chown app:dialout "${port}" 2>/dev/null; then
        _error "Failed to set ownership on ${port}"
        _error "Ensure the device is accessible and container has --device or --privileged"
        exit 1
    fi

    if ! chmod 660 "${port}" 2>/dev/null; then
        _error "Failed to set permissions on ${port}"
        exit 1
    fi

    _success "Serial port configured securely (owner: app, group: dialout, mode: 660)"
}

function _dsmr_datalogger_mode() {
    _validate_operation_mode
    local mode="${DSMRREADER_OPERATION_MODE:-standalone}"

    case "${mode}" in
        standalone)
            _info "Standalone mode: local datalogger enabled"

            # In standalone mode DSMR Reader can use configuration stored in the database.
            # Only write REMOTE_DATALOGGER settings to /app/.env when user explicitly provided them.
            local input_method="${DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD:-}"

            if [[ -z "${input_method}" ]]; then
                _info "No DSMRREADER_REMOTE_DATALOGGER_* overrides provided; using configuration from the database/UI"
                return 0
            fi

            case "${input_method}" in
                serial)
                    _info "Using serial overrides for datalogger"

                    _validate_serial_config || exit 1
                    _configure_serial_port

                    cat >> /app/.env <<EOF
DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD=${DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD}
DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT=${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PORT}
DSMRREADER_REMOTE_DATALOGGER_SERIAL_BAUDRATE=${DSMRREADER_REMOTE_DATALOGGER_SERIAL_BAUDRATE}
DSMRREADER_REMOTE_DATALOGGER_SERIAL_BYTESIZE=${DSMRREADER_REMOTE_DATALOGGER_SERIAL_BYTESIZE}
DSMRREADER_REMOTE_DATALOGGER_SERIAL_PARITY=${DSMRREADER_REMOTE_DATALOGGER_SERIAL_PARITY:-N}
EOF
                    ;;

                ipv4)
                    _info "Using IPv4 overrides for datalogger"

                    _validate_network_config || exit 1

                    cat >> /app/.env <<EOF
DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD=${DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD}
DSMRREADER_REMOTE_DATALOGGER_NETWORK_HOST=${DSMRREADER_REMOTE_DATALOGGER_NETWORK_HOST}
DSMRREADER_REMOTE_DATALOGGER_NETWORK_PORT=${DSMRREADER_REMOTE_DATALOGGER_NETWORK_PORT}
EOF
                    ;;

                *)
                    _error "Invalid DSMRREADER_REMOTE_DATALOGGER_INPUT_METHOD: ${input_method}"
                    _error "Valid options: serial, ipv4"
                    exit 1
                    ;;
            esac
            ;;

        api_server)
            _info "API server mode: no local datalogger"
            ;;

        api_client)
            _info "API client mode: remote datalogger only"

            _validate_api_client_config || exit 1

            cat >> /app/.env <<EOF
DSMRREADER_REMOTE_DATALOGGER_API_HOSTS=${DSMRREADER_REMOTE_DATALOGGER_API_HOSTS}
DSMRREADER_REMOTE_DATALOGGER_API_KEYS=${DSMRREADER_REMOTE_DATALOGGER_API_KEYS}
EOF
            ;;
    esac
}

function _optional_settings() {
    [[ -n "${DSMRREADER_REMOTE_DATALOGGER_TIMEOUT:-}" ]] && \
        echo "DSMRREADER_REMOTE_DATALOGGER_TIMEOUT=${DSMRREADER_REMOTE_DATALOGGER_TIMEOUT}" >> /app/.env

    [[ -n "${DSMRREADER_REMOTE_DATALOGGER_SLEEP:-}" ]] && \
        echo "DSMRREADER_REMOTE_DATALOGGER_SLEEP=${DSMRREADER_REMOTE_DATALOGGER_SLEEP}" >> /app/.env

    [[ -n "${DSMRREADER_REMOTE_DATALOGGER_DEBUG_LOGGING:-}" ]] && \
        echo "DSMRREADER_REMOTE_DATALOGGER_DEBUG_LOGGING=${DSMRREADER_REMOTE_DATALOGGER_DEBUG_LOGGING^^}" >> /app/.env

    [[ -n "${DSMRREADER_LOGLEVEL:-}" ]] && \
        echo "DSMRREADER_LOGLEVEL=${DSMRREADER_LOGLEVEL^^}" >> /app/.env
}

function _check_db_availability() {
    _info "Checking database credentials..."
    _validate_credentials

    local host="${DJANGO_DATABASE_HOST}"
    local port="${DJANGO_DATABASE_PORT}"
    local max_attempts=30
    local timeout=2

    _info "Connecting to database: ${host}:${port}"

    for i in $(seq 1 ${max_attempts}); do
        if timeout "${timeout}" nc -z "${host}" "${port}" 2>/dev/null; then
            _success "Database connection established after ${i} attempt(s)"

            if [[ "${ENABLE_VACUUM_DB_ON_STARTUP}" == "true" ]]; then
                _cleandb
            fi

            return 0
        fi

        _progress "Waiting for database... (${i}/${max_attempts})"
        sleep 1
    done

    _error "Database connection failed after ${max_attempts} attempts"
    _error "Check DJANGO_DATABASE_HOST and DJANGO_DATABASE_PORT settings"
    exit 1
}

function _run_post_config() {
    _info "Running Django post-configuration..."

    if ! /opt/venv/bin/python /app/manage.py migrate --noinput; then
        _error "Database migration failed"
        exit 1
    fi

    if ! /opt/venv/bin/python /app/manage.py collectstatic --noinput; then
        _error "Static file collection failed"
        exit 1
    fi

    if ! /opt/venv/bin/python /app/manage.py dsmr_superuser; then
        _error "Superuser creation failed"
        exit 1
    fi

    _success "Django configuration completed"
}

function _nginx_listen_port() {
    mkdir -p /run/nginx/server-snippets
    local port="${NGINX_LISTEN_PORT:-80}"

    _info "Configuring NGINX to listen on port ${port}"
    printf 'listen %s;\n' "${port}" > /run/nginx/server-snippets/10-listen.conf
}

function _nginx_disable_access_logs() {
    mkdir -p /run/nginx/conf.d

    if [[ "${ENABLE_NGINX_ACCESS_LOGS}" == "false" ]]; then
        _info "Disabling NGINX access logs"
        cat > /run/nginx/conf.d/00-nginx-logging.conf <<'EOF'
access_log off;
error_log  /proc/self/fd/2 warn;
EOF
    else
        _info "Enabling NGINX access and error logs"
        cat > /run/nginx/conf.d/00-nginx-logging.conf <<'EOF'
access_log /proc/self/fd/1;
error_log  /proc/self/fd/2 warn;
EOF
    fi
}

function _nginx_ssl_configuration() {
    mkdir -p /run/nginx/server-snippets
    rm -f /run/nginx/server-snippets/20-ssl.conf

    if [[ "${ENABLE_NGINX_SSL}" != "true" ]]; then
        _info "SSL disabled"
        return 0
    fi

    _info "Enabling NGINX SSL..."

    if [[ ! -f "/etc/ssl/private/fullchain.pem" || ! -f "/etc/ssl/private/privkey.pem" ]]; then
        _error "SSL certificates not found!"
        _error "Required: /etc/ssl/private/fullchain.pem and /etc/ssl/private/privkey.pem"
        exit 1
    fi

    cat > /run/nginx/server-snippets/20-ssl.conf <<'EOF'
listen 443 ssl;
ssl_certificate /etc/ssl/private/fullchain.pem;
ssl_certificate_key /etc/ssl/private/privkey.pem;
ssl_protocols TLSv1.2 TLSv1.3;
ssl_prefer_server_ciphers on;
ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
EOF

    if ! nginx -c /etc/nginx/nginx.conf -t >/dev/null 2>&1; then
        _error "NGINX SSL configuration test failed"
        nginx -c /etc/nginx/nginx.conf -t
        exit 1
    fi

    _success "SSL configured successfully"
}

function _generate_auth_configuration() {
    mkdir -p /run/nginx/server-snippets
    rm -f /run/nginx/server-snippets/30-auth.conf /run/nginx/htpasswd

    if [[ "${ENABLE_HTTP_AUTH}" != "true" ]]; then
        _info "HTTP authentication disabled"
        return 0
    fi

    _info "Enabling HTTP basic authentication..."

    if [[ -z "${HTTP_AUTH_USERNAME:-}" || -z "${HTTP_AUTH_PASSWORD:-}" ]]; then
        _error "HTTP_AUTH_USERNAME and HTTP_AUTH_PASSWORD must be set when ENABLE_HTTP_AUTH=true"
        exit 1
    fi

    local crypt_pw
    crypt_pw="$(openssl passwd -apr1 "${HTTP_AUTH_PASSWORD}")"
    printf "%s:%s\n" "${HTTP_AUTH_USERNAME}" "${crypt_pw}" > /run/nginx/htpasswd
    chmod 600 /run/nginx/htpasswd

    cat > /run/nginx/server-snippets/30-auth.conf <<'EOF'
auth_basic "Restricted Access";
auth_basic_user_file /run/nginx/htpasswd;
EOF

    if ! nginx -c /etc/nginx/nginx.conf -t >/dev/null 2>&1; then
        _error "NGINX authentication configuration test failed"
        nginx -c /etc/nginx/nginx.conf -t
        exit 1
    fi

    _success "HTTP authentication configured"
}

function _generate_clientcert_auth_configuration() {
    mkdir -p /run/nginx/server-snippets
    rm -f /run/nginx/server-snippets/40-clientcert.conf

    if [[ "${ENABLE_CLIENTCERT_AUTH}" != "true" ]]; then
        _info "Client certificate authentication disabled"
        return 0
    fi

    _info "Enabling client certificate authentication..."

    if [[ ! -f /etc/nginx/client_cert/cacert.pem ]]; then
        _error "Client certificate CA not found at /etc/nginx/client_cert/cacert.pem"
        exit 1
    fi

    cat > /run/nginx/server-snippets/40-clientcert.conf <<'EOF'
ssl_client_certificate /etc/nginx/client_cert/cacert.pem;
ssl_verify_client on;
ssl_verify_depth 2;
EOF

    if [[ -f /etc/nginx/client_cert/ca.crl ]]; then
        _info "Using certificate revocation list"
        echo "ssl_crl /etc/nginx/client_cert/ca.crl;" >> /run/nginx/server-snippets/40-clientcert.conf
    fi

    if ! nginx -c /etc/nginx/nginx.conf -t >/dev/null 2>&1; then
        _error "NGINX client certificate configuration test failed"
        nginx -c /etc/nginx/nginx.conf -t
        exit 1
    fi

    _success "Client certificate authentication configured"
}

function _docker_secrets() {
    if ! find /run/s6/container_environment -maxdepth 1 -name 'FILE__*' -print -quit 2>/dev/null | grep -q .; then
        return 0
    fi

    _info "Processing Docker secrets..."

    for FILENAME in /run/s6/container_environment/FILE__*; do
        [[ -f "${FILENAME}" ]] || continue

        local SECRETFILE
        SECRETFILE=$(cat "${FILENAME}")

        if [[ ! -f "${SECRETFILE}" ]]; then
            _warn "Secret file not found: ${SECRETFILE} (referenced by ${FILENAME##*/})"
            continue
        fi

        if [[ $(tail -c1 "${SECRETFILE}" | wc -l) -ne 0 ]]; then
            _warn "Docker secret ${FILENAME##*/} contains trailing newline - may cause issues"
        fi

        local FILESTRIP="${FILENAME//FILE__/}"
        cat "${SECRETFILE}" > "${FILESTRIP}"

        _success "Loaded Docker secret: ${FILESTRIP##*/}"
    done
}

function _iframe() {
    if [[ "${ENABLE_IFRAME}" != "true" ]]; then
        return 0
    fi

    _info "Enabling IFrame support..."

    if ! grep -q "X_FRAME_OPTIONS" /app/dsmrreader/settings.py 2>/dev/null; then
        sed -i "/^from dsmrreader.*/a X_FRAME_OPTIONS = 'ALLOWALL'" /app/dsmrreader/settings.py
        _success "IFrame support enabled"
    else
        _info "IFrame support already configured"
    fi
}

function _cleandb() {
    _info "Running database vacuum..."

    if [[ -x /app/cleandb.sh ]]; then
        /app/cleandb.sh
        _success "Database vacuum completed"
    else
        _warn "Database vacuum script not found or not executable"
    fi
}

#---------------------------------------------------------------------------------------------------------------------------
# MAIN EXECUTION
#---------------------------------------------------------------------------------------------------------------------------
function main() {
    [[ "${DEBUG}" == "true" ]] && set -x

    _info "Starting DSMR Reader initialization..."

    _pre_reqs

    # API client mode only needs datalogger configuration
    if [[ "${DSMRREADER_OPERATION_MODE}" == "api_client" ]]; then
        _info "API client mode detected - skipping web application setup"
        _dsmr_datalogger_mode
        _optional_settings
        _success "API client initialization complete"
        return 0
    fi

    # Full setup for standalone and api_server modes
    _docker_secrets
    _check_db_availability
    _iframe
    _run_post_config
    _nginx_listen_port
    _nginx_disable_access_logs
    _generate_clientcert_auth_configuration
    _nginx_ssl_configuration
    _generate_auth_configuration
    _dsmr_datalogger_mode
    _optional_settings

    _success "DSMR Reader initialization complete"
}

# Execute main function
main "$@"